<template id="aiplugs-autofields">
  <style>
    .field {
      margin-top: 24px;
      display: flex;
      flex-direction: column;
    }
    #root > .field {
      margin-top: 0;
    }

    label {
      color: var(--color-primary-text);
      margin-bottom: 6px;
      display: block;
      font-size: 16px;
    }
    aiplugs-array-item > .field,
    aiplugs-array-item .field:nth-child(1) {
      margin-top: 0;
    }

    .desc {
      color: var(--color-secondary-text);
      font-size: 12px;
      margin: 12px 0;
    }

    input:not([type="checkbox"]):not([type="radio"]),
    textarea,
    select {
      border-radius: 4px;
      border: 1px solid #999;
      padding: 12px;
      outline: none;
    }

    input:not([type="checkbox"]):not([type="radio"]),
    textarea,
    select {
      flex: 1;
    }
    input:not([type="checkbox"]):not([type="radio"]):not([type="number"]):not([type="date"]):not([type="datetime-local"]),
    textarea {
      max-width: 320px;
    }
    textarea {
      min-height: 120px;
    }
    select {
      max-width: 346px;
    }
    input[type="number"], input[type="date"], input[type="datetime-local"] {
      max-width: 160px;
    }

    input:not([type="checkbox"]):not([type="radio"]):focus,
    textarea:focus,
    select:focus {
      border-radius: 4px;
      border: 1px solid var(--color-primary);
    }

    input[type="checkbox"],
    input[type="radio"] {
      display: none;
    }

    input[type="checkbox"]~.checkbox {
      box-sizing: border-box;
      outline: 0;
      display: block;
      width: 4em;
      height: 2em;
      position: relative;
      cursor: pointer;
      user-select: none;
      background: var(--color-text-secondary);
      border-radius: 2em;
      padding: 2px;
      transition: all .4s ease;
    }

    input[type="checkbox"]~.checkbox:after,
    input[type="checkbox"]~.checkbox:before {
      position: relative;
      display: block;
      content: "";
      width: 50%;
      height: 100%;
    }

    input[type="checkbox"]~.checkbox:after {
      left: 0;
      border-radius: 50%;
      background: #fff;
      transition: all .2s ease;
    }

    input[type="checkbox"]~.checkbox:before {
      display: none;
    }

    input[type="checkbox"]:checked~.checkbox:after {
      left: 50%;
    }

    input[type="checkbox"]:checked~.checkbox {
      background: var(--color-primary);
    }

    .radio-label {
      line-height: 24px;
      display: flex;
      align-items: center;
    }

    input[type="radio"]~.radio {
      position: relative;
      display: inline-block;
      width: 24px;
      height: 24px;
      margin-right: 6px;
    }

    input[type="radio"]~.radio::before {
      position: absolute;
      display: block;
      box-sizing: border-box;
      width: 24px;
      height: 24px;
      content: "";
      border-style: solid;
      border-width: 2px;
      border-radius: 8px;
      transition: all linear .15s;
      border-color: var(--color-divider, #f0f0f0);
    }

    input[type="radio"]~.radio::after {
      position: absolute;
      display: block;
      box-sizing: border-box;
      width: 4px;
      height: 4px;
      top: 10px;
      left: 10px;
      content: "";
      border-radius: 50%;
      background: transparent;
      transition: border-radius ease-out .5s;
    }

    input[type="radio"]:checked~.radio::before {
      border-color: var(--color-primary, hsl(207, 90%, 54%));
    }

    input[type="radio"]:checked~.radio::after {
      width: 16px;
      height: 16px;
      top: 4px;
      left: 4px;
      border-radius: 4px;
      background: var(--color-primary, hsl(207, 90%, 54%));
    }
    input:invalid {
      border-color: var(--color-error) !important;
    }
  </style>
  <slot></slot>
  <div id="root"></div>
</template>
<script src="https://unpkg.com/json-schema-ref-parser@4.0.3/dist/ref-parser.min.js"></script>
<script>
  (function () {
    const tree = document.currentScript.ownerDocument;
    class XFields extends HTMLElement {
      constructor() {
        super();
        const template = tree.getElementById('aiplugs-autofields').content;
        const shadow = this.attachShadow({mode:'open'});
        shadow.appendChild(template.cloneNode(true));
        this.el = { container: shadow.querySelector('div') };
      }
      static get observedAttributes() {
        return ['schema'];
      }
      attributeChangedCallback(attrName, oldVal, newVal) {
        if (newVal) {
          if (attrName == 'schema') {
            this._init(newVal);
          }
        }
      }
      _parseSchema(schemaUrl) {
        return $RefParser.parse(schemaUrl).then(schema => {
          const hash = schemaUrl.indexOf('#');
          if (hash === -1)
            return schema;
          
          const path = schemaUrl.slice(hash+1).split('/').filter(_ => _);

          return path.reduce((s, key) => s[key], schema);
        });
      }
      _init(schemaUrl) {
        this._parseSchema(schemaUrl).then(schema => {
          let defaultData = {};
          const slot = this.shadowRoot.querySelector('slot');
          if (slot) {
            const json = slot.assignedNodes().find(el => el.constructor === HTMLScriptElement && el.type === 'application/json');
            if (json) {
              defaultData = JSON.parse(json.innerText);
            }
          }
          const template = this._render(schema, null, defaultData) || '';
          this.el.container.innerHTML = template;
        });
      }
      _render(obj, name, value, required) {
        let template = '<div class="field">';

        if (obj.hasOwnProperty('title')) {
          template += `<label>${obj.title}${required ? '*' : ''}</label>`;
        }
        if (obj.hasOwnProperty('description')) {
          template += `<p class="desc">${obj.description}</p>`;
        }
        const parent = name;
        const next = (name, obj, value, required) => this._render(obj, name, value, required);
        let postRendereds = [];
        for (let field of fields) {
          if (field.condition(obj)) {
            template += field.template(name, obj, value, required, next);
            const post = field.postRendered;
            if (post) {
              postRendereds.push(post.bind(this));
            }
            break;
          }
        }
        template += '</div>';
        requestIdleCallback(() => {
          for(let postRendered of postRendereds) {
            postRendered(name, obj, value);
          }
        });
        return template;
      }

    }
    const objectField = {
      condition: obj => obj.type === 'object',
      template: (name, obj, value, required, next) => {
        if (!value) {
          value = {};
        }
        return Object.keys(obj.properties).map(
          key => next(
            [name, key].filter(_ => _).join('.'), 
            obj.properties[key], 
            value[key], 
            (obj.required || []).indexOf(key) !== -1
          )
        ).join('')
      }
    }
    const numberField = {
      condition: obj => obj.type === 'integer' || obj.type === 'number',
      template: (name, obj, value, required) => {
        const step = obj.type === 'integer' ? '1' : 'any';
        let min = obj.minimum;
        if (obj.exclusiveMinimum)
          min += 1;
        let max = obj.maximum;
        if (obj.exclusiveMaximum)
          max -= 1;
        let range = '';
        if (min)
          range += ` min="${min}"`;
        if (max)
          range += ` max="${max}"`;
        return `<input type="number" name="${name}" value="${value||''}" step="${step}" ${range} ${required?'required':''}/>`
      },
      postRendered: inputPostRendered
    };
    const textField = {
      condition: obj => obj.type === 'string' && (!obj.input || ['text', 'email', 'password', 'tel', 'date', 'datetime'].indexOf(obj.input.type) != -1),
      template: (name, obj, value, required) => {
        const attrs = { type: (obj.input || { type: 'text' }).type, name };
        if (attrs.type === 'datetime')
          attrs.type = 'datetime-local';
        if (obj.pattern) {
          attrs.pattern = obj.pattern;
        }
        if (obj.maxLength) {
          attrs.maxlength = obj.maxLength;
          attrs.style = `max-width: ${obj.maxLength}em;`;
        }
        if (required) {
          attrs.required = 'required';
        }
        if (value) {
          attrs.value = value;
        }
        return `<input ${Object.keys(attrs).map(key => `${key}="${attrs[key]}"`).join(' ')}>`;
      },
      postRendered: inputPostRendered
    }
    const textareaField = {
      condition: obj => obj.type === 'string' && !!obj.input && obj.input.type === 'textarea',
      template: (name, obj, value, required) => `<textarea name="${name}" ${required?'required':''}>${value||''}</textarea>`,
      postRendered: inputPostRendered
    }
    const codeField = {
      condition: obj => obj.type === 'string' && !!obj.input && obj.input.type === 'code',
      template: (name, obj, value, required) => {
        const opts = obj.input.code;
        const schema = opts['json.schema']
        return `<aiplugs-monaco name='${name}'
                                value='${value||''}'
                                ${opts?`options='${JSON.stringify(opts)}'`:''} 
                                ${schema?`json-schema="${schema}"`:''} 
                                style="height: 500px;"></aiplugs-monaco>`
      }
    }
    const wysiwygField = {
      condition: obj => obj.type === 'string' && !!obj.input && obj.input.type === 'wysiwyg',
      template: (name, obj, value, required) => `<textarea name="${name}">${value||''}</textarea>`
    }
    const arrayBox = {
      condition: obj => obj.type === 'array',
      template: (name, obj, value, required, next) => {
        const values = value || [];
        const _name = obj.items.type === 'object' 
                    ? index => typeof index !== 'number' ? `${name||''}[{{index}}]` : `${name||''}[${index}]` 
                    : index => `${name}[]`;
        return `
        <aiplugs-array min="${obj.minItems || '0'}" max="${obj.maxItems || '*'}" index="${values.length}">
          <template>${next(_name(), obj.items)}</template>
          ${values.map((v, i) => `
            <aiplugs-array-item name="${_name()}">
              ${next(_name(i), obj.items,v)}
            </aiplugs-array-item>`
          )}
        </aiplugs-array>`
      }
    }
    const checkboxField = {
      condition: obj => obj.type === 'boolean',
      template: (name, obj, value, required) => `<label><input type="checkbox" name="${name}" ${value ? 'checked' : ''} ${required?'required':''}/><span class="checkbox"></span></label>`
    }
    const radioField = {
      condition: obj => obj.enum && obj.enum.length <= 5,
      template: (name, obj, value, required) => {
        const labels = obj.enumLabels || {};
        return obj.enum.map(v => `<label class="radio-label"><input type="radio" name="${name}" ${value == v ? 'checked' : ''} ${required?'required':''}/><span class="radio"></span>${labels[v] || v}</label>`).join('');
      }
    }
    const selectField = {
      condition: obj => obj.enum && obj.enum.length > 5,
      template: (name, obj, value, required) => {
        const labels = obj.enumLabels || {};
        return `<select name="${name}">${obj.enum.map(v => `<option value="${v}">${labels[v] || v}</option>`)}</select>`;
      }
    }
    const tagField = {
      condition: obj => obj.type === 'array' && obj.items && obj.items.input && obj.items.input.type === 'tag',
      template: (name, obj, value, required) => `
        <aiplugs-tag-input name="${name}" multiple>
          ${(value||[]).map(v => `<aiplugs-tag value="${tag}">${v}</aiplugs-tag>`).join('')}  
        </aiplugs-tag-input>`
    }
    const autocompleteField = {
      condition: obj => obj.type !== 'array' && !!obj.input && obj.input.type === 'autocomplete',
      template: (name, obj, value, required) => `<aiplugs-autocomplete name="${name}"></aiplugs-autocomplete>`,
      postRendered: autocompletePostRendered
    }
    const autocompleteMultipleField = {
      condition: obj => obj.type === 'array' && obj.items && obj.items.input && obj.items.input.type === 'autocomplete',
      template: (name, obj, value, required) => `<aiplugs-autocomplete name="${name}" multiple></aiplugs-autocomplete>`,
      postRendered: autocompletePostRendered
    }
    const fields = [objectField, numberField, checkboxField, radioField, selectField, textareaField, codeField, wysiwygField, tagField, autocompleteField, textField, autocompleteMultipleField, arrayBox];

    const defaultAutoCompleteOpts = {
      url: '',
      paramKey: 'hint',
      method: 'get',
      queryParams: {},
      customHeaders: {}
    }
    function requestAutocomplete(opts, hint) {
      if (typeof opts === 'string') {
        opts = { url: opts };
      }
      opts = Object.assign(defaultAutoCompleteOpts, opts);
      const params = Object.keys(opts.queryParams).map(k => `${k}=${opts.queryParams[k]}`).join('&');
      let url = opts.url + ((opts.url.indexOf('?') === -1) ? '?' : '&') + params + `&${opts.paramKey}=${hint}`;

      return fetch(url, { method: opts.method, headers: opts.customHeaders }).then(res => res.json())
    }
    function autocompletePostRendered(name, obj, value) {
      const input = obj.input || obj.items.input;
      const element = this.shadowRoot.querySelector(`aiplugs-autocomplete[name="${name}"]`);
      element.addEventListener('change', e => {
        const autocomplete = e.target;
        requestAutocomplete(input.autocomplete, e.detail.value).then(data => {
          autocomplete.suggestion = data;
        })
      });
      (value||[]).forEach(v => {
        requestAutocomplete(input.autocomplete, v).then(data => {
          const datum = data.find(d => d.value === v);
          const tag = document.createElement('aiplugs-tag');
          tag.value = datum.value;
          tag.innerText = datum.text;
          element.appendChild(tag);
        })
      })
    }
    function inputPostRendered(name, obj, value) {
    }
    window.customElements.define('aiplugs-autofields', XFields);
  }())
</script>